package org.example.candidateservice.batch.processor;

import org.example.candidateservice.batch.dto.PartnerCandidateRecord;
import org.example.candidateservice.entity.Candidate;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

// Assume Candidate and PartnerCandidateRecord are defined as per previous steps
// Assume you have a CandidateService or similar to interact with the repository
// Assume you might need a SkillService for enrichment

@Component
public class CandidateItemProcessor implements ItemProcessor<PartnerCandidateRecord, Candidate> {

    // Example: If you need to enrich data with skills or validate against existing candidates
    // private final SkillService skillService;
    // private final CandidateService candidateService; // For checking duplicates if needed

    // public CandidateItemProcessor(SkillService skillService, CandidateService candidateService) {
    //     this.skillService = skillService;
    //     this.candidateService = candidateService;
    // }

    @Override
    public Candidate process(PartnerCandidateRecord record) throws Exception {
        // 1. Validation
        if (!StringUtils.hasText(record.getEmail()) || !isValidEmail(record.getEmail())) {
            // Log invalid record or throw a SkipListener-compatible exception
            System.err.println("Skipping record due to invalid or missing email: " + record.getEmail());
            return null; // Returning null will skip this item in the batch if configured
        }
        if (!StringUtils.hasText(record.getFirstName())) {
            System.err.println("Skipping record due to missing first name for email: " + record.getEmail());
            return null;
        }

        // 2. Data Transformation and Enrichment
        Integer yearsOfExperience = null;
        if (StringUtils.hasText(record.getYearsOfExperience())) {
            try {
                yearsOfExperience = Integer.parseInt(record.getYearsOfExperience());
            } catch (NumberFormatException e) {
                System.err.println("Could not parse years of experience for email: " + record.getEmail() + ", value: " +
                                   record.getYearsOfExperience());
                // Decide how to handle this: skip, or process with null
                // For now, we'll let it be null.
            }
        }

        // Example of data enrichment: Map primarySkill to a Skill object or ID
        // Skill primarySkill = skillService.findByNameOrCreate(record.getPrimarySkill());

        // 3. Mapping to Candidate domain object
        // In a real scenario, you might check if a candidate with this email already exists
        // and decide whether to update or skip. For simplicity here, we create a new one.

        Candidate candidate = new Candidate();
        // Assuming Candidate has a unique ID, generated by the repository or DB
        // candidate.setId(UUID.randomUUID()); // Or let the persistence layer handle ID generation

        // Note: The 'user_id' would typically be linked to the Identity Service.
        // For import, this might be tricky if not provided or if it needs to be created.
        // For now, we'll leave it null and assume it might be set later or handled differently.
        // candidate.setUserId(...);

        candidate.setFirstName(record.getFirstName());
        candidate.setLastName(record.getLastName());
        candidate.setEmail(record.getEmail());
        candidate.setPhoneNumber(record.getPhone());
        candidate.setHeadline(record.getPrimarySkill()); // Using primarySkill as headline for now
        // candidate.setPrimarySkill(primarySkill); // If mapping to a Skill object
        candidate.setYearsOfExperience(yearsOfExperience); // Transformed value
        candidate.setCurrentCompany(record.getCurrentCompany());

        // Add other fields as necessary

        return candidate;
    }

    private boolean isValidEmail(String email) {
        // Basic email validation, can be replaced with a more robust regex or library
        return email.contains("@") && email.contains(".");
    }
}
